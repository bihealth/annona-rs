//! Data structures for (de-)serialization as generated by `prost-build`.

use std::str::FromStr;

use noodles_vcf::record::info::field;

use crate::common;

include!(concat!(env!("OUT_DIR"), "/annonars.gnomad_nuclear.pbs.rs"));

/// The cohorts that are available in the gnomAD-exomes/genomes VCFs.
pub static COHORTS: &[&str] = &["controls", "non_cancer", "non_neuro", "non_topmed"];

/// The populations that are available in the gnomAD-exomes/genomes VCFs.
///
/// This includes the "global" population represented by an empty string.
pub static POPS: &[&str] = &["afr", "amr", "asj", "eas", "fin", "nfe", "oth", "sas"];

/// Options struct that allows to specify which details fields are to be extracted from
/// gnomAD-exomes/genomes VCF records.
///
/// The fields that have `true` as its default are `vep`, `var_info`, and `pop_global_cohort`.
#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
pub struct DetailsOptions {
    /// Enable extraction of `Vep` records.
    pub vep: bool,
    /// Enable variant details info.
    pub var_info: bool,
    /// Enable extraction of sub populations in the "global" cohort.
    pub global_cohort_pops: bool,
    /// Enable extraction of all sub cohorts (requires `pop_global_cohorts`).
    pub all_cohorts: bool,
    /// Enable extraction of detailed random forest info.
    pub rf_info: bool,
    /// Enable extraction of detailed quality info.
    pub quality: bool,
    /// Enable extraction of detailed age info.
    pub age_hists: bool,
    /// Enable extraction of detailed depth of coverage info.
    pub depth_details: bool,
}

impl Default for DetailsOptions {
    fn default() -> Self {
        Self {
            vep: true,
            var_info: true,
            global_cohort_pops: true,
            all_cohorts: false,
            rf_info: false,
            quality: false,
            age_hists: false,
            depth_details: false,
        }
    }
}

impl DetailsOptions {
    /// Create a new `DetailsOptions` with all fields enabled.
    pub fn with_all_enabled() -> Self {
        Self {
            vep: true,
            var_info: true,
            global_cohort_pops: true,
            all_cohorts: true,
            rf_info: true,
            quality: true,
            age_hists: true,
            depth_details: true,
        }
    }
}

impl From<(String, f32)> for Prediction {
    fn from((prediction, score): (String, f32)) -> Self {
        Self { prediction, score }
    }
}

impl FromStr for Vep {
    type Err = anyhow::Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let values = s.split('|').collect::<Vec<_>>();

        Ok(Vep {
            allele: values[0].to_string(),
            consequence: values[1].to_string(),
            impact: values[2].to_string(),
            symbol: values[3].to_string(),
            gene: values[4].to_string(),
            feature_type: values[5].to_string(),
            feature: values[6].to_string(),
            feature_biotype: values[7].to_string(),
            exon: (!values[8].is_empty()).then(|| values[8].to_string()),
            intron: (!values[9].is_empty()).then(|| values[9].to_string()),
            hgvsc: (!values[10].is_empty()).then(|| values[10].to_string()),
            hgvsp: (!values[11].is_empty()).then(|| values[11].to_string()),
            cdna_position: (!values[12].is_empty()).then(|| values[12].to_string()),
            cds_position: (!values[13].is_empty()).then(|| values[13].to_string()),
            protein_position: (!values[14].is_empty()).then(|| values[14].to_string()),
            amino_acids: (!values[15].is_empty()).then(|| values[15].to_string()),
            codons: (!values[16].is_empty()).then(|| values[16].to_string()),
            existing_variation: (!values[17].is_empty()).then(|| values[17].to_string()),
            dbsnp_id: (!values[18].is_empty()).then(|| values[18].to_string()),
            distance: (!values[19].is_empty()).then(|| values[19].to_string()),
            strand: (!values[20].is_empty()).then(|| values[20].to_string()),
            flags: (!values[21].is_empty()).then(|| values[21].to_string()),
            variant_class: (!values[22].is_empty()).then(|| values[22].to_string()),
            minimised: (!values[23].is_empty()).then(|| values[23].to_string()),
            symbol_source: (!values[24].is_empty()).then(|| values[24].to_string()),
            hgnc_id: (!values[25].is_empty()).then(|| values[25].to_string()),
            canonical: values[26] == "YES",
            tsl: (!values[27].is_empty())
                .then(|| values[27].parse())
                .transpose()?,
            appris: (!values[28].is_empty()).then(|| values[28].to_string()),
            ccds: (!values[29].is_empty()).then(|| values[29].to_string()),
            ensp: (!values[30].is_empty()).then(|| values[30].to_string()),
            swissprot: (!values[31].is_empty()).then(|| values[31].to_string()),
            trembl: (!values[32].is_empty()).then(|| values[32].to_string()),
            uniparc: (!values[33].is_empty()).then(|| values[33].to_string()),
            gene_pheno: (!values[34].is_empty()).then(|| values[34].to_string()),
            sift: (!values[35].is_empty())
                .then(|| -> Result<(String, f32), anyhow::Error> {
                    dbg!(values[35]);
                    let tokens = values[35].split('(').collect::<Vec<_>>();
                    let mut tmp = tokens[1].chars();
                    tmp.next_back();
                    let score = tmp.as_str();
                    Ok((tokens[0].to_string(), score.parse::<f32>()?))
                })
                .transpose()?
                .map(|val| val.into()),
            polyphen: (!values[36].is_empty())
                .then(|| -> Result<(String, f32), anyhow::Error> {
                    let tokens = values[36].split('(').collect::<Vec<_>>();
                    let mut tmp = tokens[1].chars();
                    tmp.next_back();
                    let score = tmp.as_str();
                    Ok((tokens[0].to_string(), score.parse::<f32>()?))
                })
                .transpose()?
                .map(|val| val.into()),
            domains: (!values[37].is_empty())
                .then(|| {
                    let pairs = values[37].split('&').collect::<Vec<_>>();
                    pairs
                        .iter()
                        .map(|p| {
                            let tmp = p.split(':').collect::<Vec<_>>();
                            Domain {
                                source: tmp[0].to_string(),
                                id: tmp[1].to_string(),
                            }
                        })
                        .collect::<Vec<_>>()
                })
                .unwrap_or_default(),
            hgvs_offset: (!values[38].is_empty()).then(|| values[38].to_string()),
            gmaf: (!values[39].is_empty())
                .then(|| values[39].split(':').next_back().unwrap().parse())
                .transpose()?,
            afr_maf: (!values[40].is_empty())
                .then(|| values[40].split(':').next_back().unwrap().parse())
                .transpose()?,
            amr_maf: (!values[41].is_empty())
                .then(|| values[41].split(':').next_back().unwrap().parse())
                .transpose()?,
            eas_maf: (!values[42].is_empty())
                .then(|| values[42].split(':').next_back().unwrap().parse())
                .transpose()?,
            eur_maf: (!values[43].is_empty())
                .then(|| values[43].split(':').next_back().unwrap().parse())
                .transpose()?,
            sas_maf: (!values[44].is_empty())
                .then(|| values[44].split(':').next_back().unwrap().parse())
                .transpose()?,
            aa_maf: (!values[45].is_empty())
                .then(|| values[45].split(':').next_back().unwrap().parse())
                .transpose()?,
            ea_maf: (!values[46].is_empty())
                .then(|| values[46].split(':').next_back().unwrap().parse())
                .transpose()?,
            exac_maf: (!values[47].is_empty())
                .then(|| values[47].split(':').next_back().unwrap().parse())
                .transpose()?,
            exac_adj_maf: (!values[48].is_empty())
                .then(|| values[48].split(':').next_back().unwrap().parse())
                .transpose()?,
            exac_afr_maf: (!values[49].is_empty())
                .then(|| values[49].split(':').next_back().unwrap().parse())
                .transpose()?,
            exac_amr_maf: (!values[50].is_empty())
                .then(|| values[50].split(':').next_back().unwrap().parse())
                .transpose()?,
            exac_eas_maf: (!values[51].is_empty())
                .then(|| values[51].split(':').next_back().unwrap().parse())
                .transpose()?,
            exac_fin_maf: (!values[52].is_empty())
                .then(|| values[52].split(':').next_back().unwrap().parse())
                .transpose()?,
            exac_nfe_maf: (!values[53].is_empty())
                .then(|| values[53].split(':').next_back().unwrap().parse())
                .transpose()?,
            exac_oth_maf: (!values[54].is_empty())
                .then(|| values[54].split(':').next_back().unwrap().parse())
                .transpose()?,
            exac_sas_maf: (!values[55].is_empty())
                .then(|| values[55].split(':').next_back().unwrap().parse())
                .transpose()?,
            clin_sig: (!values[56].is_empty()).then(|| values[56].to_string()),
            somatic: (!values[57].is_empty()).then(|| values[57].to_string()),
            pheno: (!values[58].is_empty()).then(|| values[58].to_string()),
            pubmed: (!values[59].is_empty()).then(|| values[59].to_string()),
            motif_name: (!values[60].is_empty()).then(|| values[60].to_string()),
            motif_pos: (!values[61].is_empty()).then(|| values[61].to_string()),
            high_inf_pos: (!values[62].is_empty()).then(|| values[62].to_string()),
            motif_score_change: (!values[63].is_empty()).then(|| values[63].to_string()),
            lof: (!values[64].is_empty()).then(|| values[64].to_string()),
            lof_filter: (!values[65].is_empty()).then(|| values[65].to_string()),
            lof_flags: (!values[66].is_empty()).then(|| values[66].to_string()),
            lof_info: (!values[67].is_empty()).then(|| values[67].to_string()),
        })
    }
}

impl Record {
    /// Creates a new `Record` from a VCF record and allele number.
    pub fn from_vcf_allele(
        record: &noodles_vcf::record::Record,
        allele_no: usize,
        options: &DetailsOptions,
    ) -> Result<Self, anyhow::Error> {
        assert!(allele_no == 0, "only allele 0 is supported");

        assert!(allele_no == 0, "only allele 0 is supported");

        // Extract mandatory fields.
        let chrom = record.chromosome().to_string();
        let pos: usize = record.position().into();
        let pos = pos as i32;
        let ref_allele = record.reference_bases().to_string();
        let alt_allele = record
            .alternate_bases()
            .get(allele_no)
            .ok_or_else(|| anyhow::anyhow!("no such allele: {}", allele_no))?
            .to_string();
        let filters = Self::extract_filters(record)?;
        let allele_counts = Self::extract_cohorts_allele_counts(record, options)?;
        let nonpar = common::noodles::get_flag(record, "nonpar")?;

        // Extract optional fields.
        let vep = options
            .vep
            .then(|| Self::extract_vep(record))
            .transpose()?
            .unwrap_or_default();
        let rf_info = options
            .rf_info
            .then(|| Self::extract_rf_info(record))
            .transpose()?;
        let variant_info = options
            .var_info
            .then(|| Self::extract_variant_info(record))
            .transpose()?;
        let quality_info = options
            .quality
            .then(|| Self::extract_quality(record))
            .transpose()?;
        let age_info = options
            .age_hists
            .then(|| Self::extract_age(record))
            .transpose()?;
        let depth_info = options
            .depth_details
            .then(|| Self::extract_depth(record))
            .transpose()?;

        Ok(Self {
            chrom,
            pos,
            ref_allele,
            alt_allele,
            filters,
            vep,
            allele_counts,
            nonpar,
            rf_info,
            variant_info,
            quality_info,
            age_info,
            depth_info,
        })
    }

    /// Extract the "vep" field.
    fn extract_vep(record: &noodles_vcf::Record) -> Result<Vec<Vep>, anyhow::Error> {
        if let Some(Some(field::Value::Array(field::value::Array::String(v)))) =
            record.info().get(&field::Key::from_str("vep")?)
        {
            v.iter()
                .flat_map(|v| v.as_ref().map(|s| Vep::from_str(s)))
                .collect::<Result<Vec<_>, _>>()
        } else {
            anyhow::bail!("missing INFO/vep in gnomAD-mtDNA record")
        }
    }

    /// Extract the details on the random forest.
    fn extract_rf_info(record: &noodles_vcf::Record) -> Result<RandomForestInfo, anyhow::Error> {
        Ok(RandomForestInfo {
            rf_tp_probability: common::noodles::get_f32(record, "rf_tp_probability")?,
            rf_positive_label: common::noodles::get_flag(record, "rf_positive_label")?,
            rf_negative_label: common::noodles::get_flag(record, "rf_negative_label")?,
            rf_label: common::noodles::get_string(record, "rf_label")?,
            rf_train: common::noodles::get_flag(record, "rf_train")?,
        })
    }

    /// Extract the details on the variant.
    fn extract_variant_info(record: &noodles_vcf::Record) -> Result<VariantInfo, anyhow::Error> {
        Ok(VariantInfo {
            variant_type: common::noodles::get_string(record, "rf_label")?,
            allele_type: common::noodles::get_string(record, "allele_type")?,
            n_alt_alleles: common::noodles::get_i32(record, "n_alt_alleles")?,
            was_mixed: common::noodles::get_flag(record, "was_mixed")?,
            has_star: common::noodles::get_flag(record, "has_star")?,
        })
    }

    /// Extract the filters fields.
    fn extract_filters(record: &noodles_vcf::Record) -> Result<Vec<i32>, anyhow::Error> {
        Ok(
            if let Some(Some(field::Value::Array(field::value::Array::String(value)))) =
                record.info().get(&field::Key::from_str("filters")?)
            {
                value
                    .iter()
                    .map(|v| match v.as_ref().map(|s| s.as_str()) {
                        Some("AC0") => Ok(Filter::AlleleCountIsZero as i32),
                        Some("InbreedingCoeff") => Ok(Filter::InbreedingCoeff as i32),
                        Some("PASS") => Ok(Filter::Pass as i32),
                        Some("RF") => Ok(Filter::RandomForest as i32),
                        Some(val) => anyhow::bail!("invalid filter value {}", val),
                        None => anyhow::bail!("missing filter value"),
                    })
                    .collect::<Result<Vec<_>, _>>()?
            } else {
                Vec::new()
            },
        )
    }

    /// Extract the age related fields from the VCF record.
    fn extract_age(record: &noodles_vcf::record::Record) -> Result<AgeInfo, anyhow::Error> {
        Ok(AgeInfo {
            age_hist_hom_bin_freq: common::noodles::get_vec::<i32>(record, "age_hist_hom_bin_freq")
                .unwrap_or_default(),
            age_hist_hom_n_smaller: common::noodles::get_i32(record, "age_hist_hom_n_smaller").ok(),
            age_hist_hom_n_larger: common::noodles::get_i32(record, "age_hist_hom_n_larger").ok(),
            age_hist_het_bin_freq: common::noodles::get_vec::<i32>(record, "age_hist_het_bin_freq")
                .unwrap_or_default(),
            age_hist_het_n_smaller: common::noodles::get_i32(record, "age_hist_het_n_smaller").ok(),
            age_hist_het_n_larger: common::noodles::get_i32(record, "age_hist_het_n_larger").ok(),
        })
    }

    /// Extract the depth related fields from the VCF record.
    fn extract_depth(record: &noodles_vcf::record::Record) -> Result<DepthInfo, anyhow::Error> {
        Ok(DepthInfo {
            dp_hist_all_n_larger: common::noodles::get_i32(record, "dp_hist_all_n_larger").ok(),
            dp_hist_alt_n_larger: common::noodles::get_i32(record, "dp_hist_alt_n_larger").ok(),
            dp_hist_all_bin_freq: common::noodles::get_vec::<i32>(record, "dp_hist_all_bin_freq")
                .unwrap_or_default(),
            dp_hist_alt_bin_freq: common::noodles::get_vec::<i32>(record, "dp_hist_alt_bin_freq")
                .unwrap_or_default(),
        })
    }

    /// Extract the quality-related fields from the VCF record.
    fn extract_quality(record: &noodles_vcf::record::Record) -> Result<QualityInfo, anyhow::Error> {
        Ok(QualityInfo {
            fs: common::noodles::get_f32(record, "FS")?,
            inbreeding_coeff: common::noodles::get_f32(record, "InbreedingCoeff")?,
            mq: common::noodles::get_f32(record, "MQ")?,
            mq_rank_sum: common::noodles::get_f32(record, "MQRankSum")?,
            qd: common::noodles::get_f32(record, "QD")?,
            read_pos_ranksum: common::noodles::get_f32(record, "ReadPosRankSum")?,
            sor: common::noodles::get_f32(record, "SOR")?,
            vqsr_positive_train_site: common::noodles::get_flag(
                record,
                "VQSR_POSITIVE_TRAIN_SITE",
            )?,
            vqsr_negative_train_site: common::noodles::get_flag(
                record,
                "VQSR_NEGATIVE_TRAIN_SITE",
            )?,
            base_q_rank_sum: common::noodles::get_f32(record, "BaseQRankSum")?,
            clipping_rank_sum: common::noodles::get_f32(record, "ClippingRankSum")?,
            dp: common::noodles::get_i32(record, "DP")?,
            vqslod: common::noodles::get_f32(record, "VQSLOD")?,
            vqsr_culprit: common::noodles::get_string(record, "VQSR_culprit")?,
            segdup: common::noodles::get_flag(record, "segdup")?,
            lcr: common::noodles::get_flag(record, "lcr")?,
            decoy: common::noodles::get_flag(record, "decoy")?,
            transmitted_singleton: common::noodles::get_flag(record, "transmitted_singleton")?,
            pab_max: common::noodles::get_f32(record, "pab_max")?,
        })
    }

    /// Extract the allele counts from the `record` as configured in `options`.
    fn extract_cohorts_allele_counts(
        record: &noodles_vcf::Record,
        options: &DetailsOptions,
    ) -> Result<Vec<CohortAlleleCounts>, anyhow::Error> {
        // Initialize global cohort.  We will always extract the non-population specific
        // counts for them.
        let mut global_counts = CohortAlleleCounts {
            cohort: None,
            by_sex: Some(AlleleCountsBySex {
                overall: Some(Self::extract_allele_counts(record, "", "")?),
                female: Some(Self::extract_allele_counts(record, "", "_female")?),
                male: Some(Self::extract_allele_counts(record, "", "_male")?),
            }),
            raw: Some(Self::extract_allele_counts(record, "", "_raw")?),
            popmax: common::noodles::get_string(record, "popmax")?,
            af_popmax: common::noodles::get_f32(record, "AF_popmax")?,
            ac_popmax: common::noodles::get_i32(record, "AC_popmax")?,
            an_popmax: common::noodles::get_i32(record, "AN_popmax")?,
            nhomalt_popmax: common::noodles::get_i32(record, "nhomalt_popmax")?,
            by_population: Vec::new(), // maybe filled below
        };

        // If configured to do so, extract the population specific counts.
        if options.global_cohort_pops {
            for pop in POPS {
                global_counts
                    .by_population
                    .push(Self::extract_population_allele_counts(record, "", pop)?);
            }
        }

        // If configured, extract all populations in all cohorts.
        let mut result = vec![global_counts];
        if options.all_cohorts {
            for cohort in COHORTS {
                let prefix = format!("{}_", cohort);
                let mut cohort_counts = CohortAlleleCounts {
                    cohort: Some(cohort.to_string()),
                    by_sex: Some(AlleleCountsBySex {
                        overall: Some(Self::extract_allele_counts(record, &prefix, "")?),
                        female: Some(Self::extract_allele_counts(record, &prefix, "_female")?),
                        male: Some(Self::extract_allele_counts(record, &prefix, "_male")?),
                    }),
                    raw: Some(Self::extract_allele_counts(record, &prefix, "_raw")?),
                    popmax: common::noodles::get_string(record, &format!("{}_popmax", cohort))?,
                    af_popmax: common::noodles::get_f32(record, &format!("{}_AF_popmax", cohort))?,
                    ac_popmax: common::noodles::get_i32(record, &format!("{}_AC_popmax", cohort))?,
                    an_popmax: common::noodles::get_i32(record, &format!("{}_AN_popmax", cohort))?,
                    nhomalt_popmax: common::noodles::get_i32(
                        record,
                        &format!("{}_nhomalt_popmax", cohort),
                    )?,
                    by_population: Vec::new(), // to be filled below
                };

                for pop in POPS {
                    cohort_counts
                        .by_population
                        .push(Self::extract_population_allele_counts(
                            record, &prefix, pop,
                        )?);
                }

                result.push(cohort_counts);
            }
        }

        Ok(result)
    }

    /// Extrac the population allele counts from the `record`.
    fn extract_population_allele_counts(
        record: &noodles_vcf::Record,
        prefix: &str,
        pop: &str,
    ) -> Result<PopulationAlleleCounts, anyhow::Error> {
        Ok(PopulationAlleleCounts {
            population: pop.to_string(),
            counts: Some(AlleleCountsBySex {
                overall: Some(Self::extract_allele_counts(
                    record,
                    prefix,
                    &format!("_{}", pop),
                )?),
                female: Some(Self::extract_allele_counts(
                    record,
                    prefix,
                    &format!("_{}_female", pop),
                )?),
                male: Some(Self::extract_allele_counts(
                    record,
                    prefix,
                    &format!("_{}_male", pop),
                )?),
            }),
            faf95: common::noodles::get_f32(record, &format!("faf95_{}", pop))?,
            faf99: common::noodles::get_f32(record, &format!("faf99_{}", pop))?,
        })
    }

    /// Extract the allele counts from the `record` with the given prefix and suffix.
    fn extract_allele_counts(
        record: &noodles_vcf::Record,
        prefix: &str,
        suffix: &str,
    ) -> Result<AlleleCounts, anyhow::Error> {
        Ok(AlleleCounts {
            ac: common::noodles::get_i32(record, &format!("{}AC{}", prefix, suffix))?,
            an: common::noodles::get_i32(record, &format!("{}AN{}", prefix, suffix))?,
            nhomalt: common::noodles::get_i32(record, &format!("{}nhomalt{}", prefix, suffix))?,
            af: common::noodles::get_f32(record, &format!("{}AF{}", prefix, suffix))?,
        })
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_vep_from_string_snv() {
        let s = "\
        G|missense_variant|MODERATE|PCSK9|ENSG00000169174|Transcript|ENST00000302118|\
        protein_coding|1/12||ENST00000302118.5:c.89C>G|ENSP00000303208.5:p.Ala30Gly|379|89|30|\
        A/G|gCg/gGg||1||1||SNV|1|HGNC|20001|YES|||CCDS603.1|ENSP00000303208|Q8NBP7||\
        UPI00001615E1|1|deleterious_low_confidence(0.03)|possibly_damaging(0.583)|\
        Cleavage_site_(Signalp):SignalP-noTM&hmmpanther:PTHR10795&hmmpanther:PTHR10795:SF333\
        ||||||||||||||||||||||||||||||DE_NOVO_DONOR_PROB:0.146539915246404&MUTANT_DONOR_MES:\
        8.16693067332728&DE_NOVO_DONOR_POS:-119&INTRON_END:55509515&DE_NOVO_DONOR_MES_POS:-122&\
        INTRON_START:55505718&EXON_END:55505717&EXON_START:55505221&DE_NOVO_DONOR_MES:\
        -1.61109392005567";
        let vep = Vep::from_str(s).unwrap();

        insta::assert_yaml_snapshot!(vep);
    }

    #[test]
    fn test_vep_from_string_indel() {
        let s = "\
        A|frameshift_variant|HIGH|PCSK9|ENSG00000169174|Transcript|ENST00000452118|\
        protein_coding|4/6||ENST00000452118.2:c.547_548insA|ENSP00000401598.2:\
        p.Gly183GlufsTer23|627-628|547-548|183|G/EX|ggc/gAgc|rs527413419|1||1||insertion\
        |1|HGNC|20001|||||ENSP00000401598||B4DEZ9|UPI00017A6F55|1|||||A:0.0032||A:0.0113\
        |A:0.0014|A:0|A:0|A:0|||||||||||||||||||HC|||GERP_DIST:364.1444&BP_DIST:304&\
        PERCENTILE:0.885113268608414&DIST_FROM_LAST_EXON:210&50_BP_RULE:PASS&\
        PHYLOCSF_TOO_SHORT";
        let vep = Vep::from_str(s).unwrap();

        insta::assert_yaml_snapshot!(vep);
    }

    #[test]
    fn test_record_from_vcf_allele_gnomad_exomes() -> Result<(), anyhow::Error> {
        let path_vcf = "tests/gnomad-nuclear/example-exomes/gnomad-exomes.vcf";
        let mut reader_vcf =
            noodles_util::variant::reader::Builder::default().build_from_path(path_vcf)?;
        let header = reader_vcf.read_header()?;

        let mut records = Vec::new();
        for row in reader_vcf.records(&header) {
            let vcf_record = row?;
            let record =
                Record::from_vcf_allele(&vcf_record, 0, &DetailsOptions::with_all_enabled())?;
            records.push(record);
        }

        insta::assert_yaml_snapshot!(records);

        Ok(())
    }

    #[test]
    fn test_record_from_vcf_allele_gnomad_genomes() -> Result<(), anyhow::Error> {
        let path_vcf = "tests/gnomad-nuclear/example-genomes/gnomad-genomes.vcf";
        let mut reader_vcf =
            noodles_util::variant::reader::Builder::default().build_from_path(path_vcf)?;
        let header = reader_vcf.read_header()?;

        let mut records = Vec::new();
        for row in reader_vcf.records(&header) {
            let vcf_record = row?;
            let record =
                Record::from_vcf_allele(&vcf_record, 0, &DetailsOptions::with_all_enabled())?;
            records.push(record);
        }

        insta::assert_yaml_snapshot!(records);

        Ok(())
    }
}
